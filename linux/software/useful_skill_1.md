# 让进程在后台可靠运行的几种方法

[Linux 技巧：让进程在后台可靠运行的几种方法](https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/)好文章，学习了！


我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。


### nohup/setsid/&

#### 场景：

如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？

#### 解决方法：

我们知道，当用户注销（logout）或者网络断开时，终端会收到HUP（hangup）信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。

#### 1. nohup

nohup 无疑是我们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。  
可见，nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上"&"来将命令同时放入后台运行，也可用">filename 2>&1"来更改缺省的重定向文件名。

```
nohup cmd &
nohup cmd > filename 2>&1 &
```

#### 2. setsid

nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。setsid 就能帮助我们做到这一点。  
可见 setsid 的使用也是非常方便的，也只需在要处理的命令前加上 setsid 即可。

值得注意的是，上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。请将此例与nohup 例中的父 ID 做比较。

```
setsid cmd
```


#### 3. &

这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。  
当我们将"&"也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过jobs来查看的。让我们来看看为什么这样就能躲过 HUP 信号的影响吧。  
从上例中可以看出，新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。  

```
(ping www.baidu.com &)
```

----

### disown

#### 场景：

我们已经知道，如果事先在命令前加上 nohup 或者 setsid 就可以避免 HUP 信号的影响。但是如果我们未加任何处理就已经提交了命令，该如何补救才能让它避免 HUP 信号的影响呢？

#### 解决方法：

这时想加 nohup 或者 setsid 已经为时已晚，只能通过作业调度和 disown 来解决这个问题了。  

- 用disown -h jobspec来使某个作业忽略HUP信号。
- 用disown -ah 来使所有的作业都忽略HUP信号。
- 用disown -rh 来使正在运行的作业忽略HUP信号。

**需要注意的是，**当使用过 disown 之后，会将把目标作业从作业列表中移除，我们将不能再使用jobs来查看它，但是依然能够用ps -ef查找到它。

```
disown -h %1
```

----


# screen

#### 场景：

我们已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？

#### 解决方法：

此时最方便的方法就是 screen 了。简单的说，screen 提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。

### 命令

screen [选项] 作业名称

选项|作用
---|---
**-S <作业名称>**|指定screen作业的名称 
**-r <作业名称>**|恢复离线的screen作业
**-ls或--list**|显示目前所有的screen作业
-A |将所有的视窗都调整为目前终端机的大小
-d <作业名称>|将指定的screen作业离线
-h <行数>|指定视窗的缓冲区行数
-m|即使目前已在作业中的screen作业，仍强制建立新的screen作业
-R|先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业
-s|指定建立新视窗时，所要执行的shell
-v|显示版本信息
-x|恢复之前离线的screen作业
-wipe|检查目前所有的screen作业，并删除已经无法使用的screen作业


**在每个screen session下，所有命令都以ctrl+a(C-a)开始。**

命令|作用
---|---
C-a d|detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。 
C-a k|kill window，强行关闭当前的 window
  





