# postgres index

### 1. 索引的类型

##### 1. B-Tree

B-Tree索引是默认的索引类型，主要用于等于和范围查询，特别是当索引列包含操作符" <、<=、=、>=和>"作为查询条件时，PostgreSQL的查询规划器都会考虑使用B-Tree索引。在使用BETWEEN、IN、IS NULL和IS NOT NULL的查询中，PostgreSQL也可以使用B-Tree索引。然而对于基于模式匹配操作符的查询，如LIKE、ILIKE、~和 ~*，仅当模式存在一个常量，且该常量位于模式字符串的开头时，如col LIKE 'foo%'或col ~ '^foo'，索引才会生效，否则将会执行全表扫描，如：col LIKE '%bar'。 

##### 2. Hash索引

散列(Hash)索引只能处理简单的等于比较。当索引列使用等于操作符进行比较时，查询规划器会考虑使用散列索引。  
这里需要额外说明的是，PostgreSQL散列索引的性能不比B-Tree索引强，但是散列索引的尺寸和构造时间则更差。另外，由于散列索引操作目前没有记录WAL日志，因此一旦发生了数据库崩溃，我们将不得不用REINDEX重建散列索引。

##### 3. GiST索引(Generalized Search Tree)

GiST索引不是一种单独的索引类型，而是一种架构，可以在该架构上实现很多不同的索引策略。从而可以使GiST索引根据不同的索引策略，而使用特定的操作符类型。

##### 4. GIN索引(Generalized Inverted Indexes)

GIN索引是反转索引，它可以处理包含多个键的值(比如数组)。与GiST类似，GIN同样支持用户定义的索引策略，从而可以使GIN索引根据不同的索引策略，而使用特定的操作符类型。

##### 5. SP-GiST索引

SP-GiST索引类似于GiST索引,提供一个支持不同类型检索的架构。 SP-GiST允许实现许多 各种不同的非平衡的基于磁盘的数据结构,例如四叉树,k-d树和基数树(字典树)。 作为示 例,PostgreSQL的标准发布中包含用于二维点的SP-GiST操作符类, 它支持`<< >> ~= <@ <^ >^`操作符的索引查询。

### 2. 多字段索引

例子：

```
CREATE INDEX index_name ON tbl_name (column_name1,column_name2...);
```

只有 B-tree , GiST和 GIN 支持多字段索引。

##### 1. B-Tree类型的复合索引

在B-Tree类型的复合索引中，该索引字段的任意子集均可用于查询条件，不过，只有当复合索引中的**第一个索引字段(最左边)被包含其中时**，才可以获得最高效率。
    
##### 2. GiST类型的复合索引

在GiST类型的复合索引中，只有当第一个索引字段被包含在查询条件中时，才能决定该查询会扫描多少索引数据，而其他索引字段上的条件只是会限制索引返回的条目。假如第一个索引字段上的大多数数据都有相同的键值，那么此时应用GiST索引就会比较低效。 

##### 3. GIN类型的复合索引

与B-Tree和GiST索引不同的是，GIN复合索引不会受到查询条件中使用了哪些索引字段子集的影响，无论是哪种组合，都会得到相同的效率。

**注意**使用复合索引应该谨慎。在大多数情况下，单一字段上的索引就已经足够了，并且还节约时间和空间。除非表的使用模式非常固定，否则超过三个字段的索引几乎没什么用处。 

### 3. 唯一索引

目前，只有B-Tree索引可以被声明为唯一索引。

例子：

```
CREATE UNIQUE INDEX name ON table (column [, ...]);
```

### 4. 部分索引

部分索引包含表数据的一个子集。它是一个带有WHERE子句的索引。这个概念是为了提高索引的效率,减少索引的大小。小的索引占更少的存储空间，易于维护，扫描更快。

例子：

```
CREATE INDEX articles_flagged_created_at_index ON articles(created_at) WHERE flagged IS TRUE;
```

### 5. 表达式索引

表达式索引对于匹配一些函数或修改的数据是有用的。Postgres允许你索引函数结果，以便搜索变得像通过原始数据值搜索一样有效。例如，你可能要求用户保存他们的邮箱登录地址，但你想大小写不敏感的认证。在这种情况下可以保存邮件地址，但是搜索上使用WHERE lower(email) = '<lowercased-email>'。在这种查询下，唯一使用索引的方式是通过表达式索引，例如这样：  

```
CREATE INDEX users_lower_email ON users(lower(email));
```

另一个常见例子是，查找给定日期的行，这里我们已经保存时间戳在一个datatime字段，但是想通过转换的date值来查找他们。一个像这样子的索引：  

```
CREATE INDEX articles_day ON articles ( date(published_at) )
```

可以用在包含WHERE date(articles.created_at) = date('2011-03-07')的查询中使用。


### 6. 组合多个索引


大多数最简单的应用里,可能有多种索引组合都是有用的,数据库开发人员必须在使用哪 个索引之间作出平衡。 有时候多字段索引是最好的,有时候创建一个独立索引并依靠索引组 合是最好的。比如, 假如你的查询有时候只涉及字段x,有时候只涉及字段y,有时候两个字段都涉及,  

那么你可能会选择在x和y上创建两个独立的索引, 然后依靠索引组合来处理同时使用两个字段的查询。  

你也可以在(x, y)上创建一个多字段索引,它在同时使用两个字 段的查询通常比索引组合更高效,但是,它对那些只包 含y的查询几乎没有用,因此它不能是唯一一个索引。 

一个多字段索引和y上的独立索引可能会更好。因为对那些只涉及x的查询, 可以使用多字段索引,但是它会更大,因此也比只在x上的索引更慢。

最后一个选择是创建三个索引, 但是这种方法只有在表的更新远比查询少,并且所有三种查询都很普遍的情况下才是合理的。 如果其中一种查询比其它的少很多, 那么你可能更愿意仅仅创建两种匹配更常见查询的索引。


### 建议

##### 1

当你准备在你的生产数据库上应用一个索引时，请记住创建索引会锁表并阻塞写操作。对于大表，这可能意味着你的网站是停机几个小时。幸运的是，Postgres允许你CREATE INDEX CONCURRENTLY（并发创建索引），这会导致花更多的时间来建索引，但是不要求锁住写锁。正常的CREATE INDEX命令要求一个锁来锁住写操作，但允许读。最终，在之后一段时间，索引会变得碎片和未优化，如果在表中的行经常更新或删除就特别容易这样。在这种情况下，就可能需要执行一个REINDEX命令来平衡及优化你的索引了。然而，要谨慎重建索引会在父表中获得写锁。有个策略在在线的网站来实现相同的结果就是并发地在相同的表和列但有一个不同的名称的索引，然后，删除旧的索引并且重新命名新的索引。这个过程可能持续比较久，但不要求在在线的(活跃）表有任何长久执行的锁。当准备创建B树索引时Postgres提供了许多灵活性来优化你特定的使用情况，也有许多选项来管理你应用程序不断增长的数据库。这些建议应该会帮你保持你的数据库健康，以及你的查询非常爽快。

##### 2. 总是先运行ANALYZE

总是先运行ANALYZE命令收集关于表中数值分布的统计信息。估计一个查询返回的行数 需要这个信息,而规划器需要这个行数以便给每个可能的查询规划赋予真实开销值。 如果 缺乏任何真实的统计信息,那么就会假设一些缺省数值,那肯定是不准确的。因此, 如果 还没有运行ANALYZE就检查一个应用的索引使用状况,那实际上就是一次失败的检查。

##### 3. 使用真实的数据做实验

用测试数据设置索引将告诉你在测试数据中需要什么索引,而不是在真实数据中。

用测试数据填充数据表，那么该表的索引将只会基于测试数据来评估该如何使用索引，而不是对所有的数据都如此使用。比如从100000行中选1000行，规划器可能会考虑使用索引，那么如果从100行中选1行就很难说也会使用索引了。因为100行的数据很可能是存储在一个磁盘页面中，然而没有任何查询规划能比通过顺序访问一个磁盘页面更加高效了。与此同时，在模拟测试数据时也要注意，如果这些数据是非常相似的数据、完全随机的数据，或按照排序顺序插入的数据，都会令统计信息偏离实际数据应该具有的特征。    

##### 4

如果索引没有得到使用,那么在测试中强制它的使用也许有些价值。有一些运行 时参数可以关闭各种各样的查询规划。 比如,关闭顺序扫 描(enable_seqscan)和嵌套循环连接(enable_nestloop) 将强迫系统使用不同的规划。如 果系统仍然选择顺序扫描或者嵌套循环连接, 那么在为何索引没有得到使用的问题中可能 有更基本的问题,比如, 查询条件和索引不匹配等。

##### 5

如果强制索引用法确实使用了索引,那么就有两种可能:要么是系统选择是正确的:使用索引实际上并不合适,要么是查询计划的开销计算并不反映现实情况。 这样你就应该对使 用和不使用索引的查询进行计时。这个时候EXPLAIN ANALYZE命令就很有用了。

##### 6 

如果实际情况说明开销计算是错误的,那么仍然有两种可能。总开销是从每行的每个规划 节点的开销乘以每个规划节点的选择性估计计算出来的。 规划节点的开销估计可以用一些 运行时参数进行调节。不准确的选择性估计是因为统计信息不够充 分。 我们可以通过调节统计收集参数提高选择性估计的精度。
